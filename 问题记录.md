# cs144 问题记录

## Lab1


1. CS144编译要求，
* 项目中使用的代码审查工具-Werror=effc++ 强制要求将成员变量初始化放在成员初始化列表中
* 成员变量构造函数中初始化的顺序要和在类中的声明顺序一致

2.  5 - byte_stream_one_write (Timeout) AddressSanitizer:DEADLYSIGNAL
![alt text](image/问题记录/PixPin_2024-08-09_18-59-31.png)

3. reassembler_single: The object should have had bytes_pushed = 1, but instead it was 0.
![alt text](image/问题记录/Clip_2024-08-10_12-19-57.png)
原因：substr(size_t pos, size_t counts)，pos:子串的起始位置，counts:字串的长度

4. reassebbler_single: The object should have had is_finished = true, but instead it was false.
![alt text](image/问题记录/Clip_2024-08-10_16-21-48.png)
原因：当 Reassembler 重组写入完成的时候，没有关闭 bytestream 
解决方法：添加变量 end_byte_index 标记字节流的结束位置，Reassembler重组写入完成时，关闭bytestream。因为end_byte_index类型是 unint64_t,不能初始化为-1，所以使用一个bool类型的变量 is_eof 标记end_byte_index是否有效

5. reassembler_cap: The object should have had bytes_pushed = 4, but instead it was 2.
![alt text](image/问题记录/Clip_2024-08-11_15-15-58.png)
原因：first_unacceptable_index的更新时机问题：只在把数据push到ByteStream后更新了 first_unacceptable_index，但是在insert函数不执行期间，ByteStream buffer的数据可能被读取，available_capacity的值可能更新，所以需要在insert函数的开始更新 first_unacceptable_index。
解决方法：在insert函数的开始更新 first_unacceptable_index。

6. 调试过程中发现在Reassembler的Insert中对插入数据为空字符串情况的处理有冗余：在插入数据为空的情况下，还是会进行storge,push操作，而且这种情况下，即使output_.writer()已经关闭，还是会进行push操作。